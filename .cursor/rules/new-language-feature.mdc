---
description: 
globs: 
alwaysApply: false
---
To add a new feature to our extended SQL language, first decide what _kind_ of language component to add. The four types below are in order of increasing difficulty. Choose the first one that suits your feature.

When writing documentation, you can write Pikchr diagrams, but I must convert the .pikchr to .svg for you. Always ask me to do this for you after creating a .pikchr file in `doc/art/`. I will also show you what the diagram looks like so you can make iterative improvements.

# Scalar-valued function
This is an SQLite custom function.
1. Implement subclass of `SqlNotebookScript/CustomScalarFunction.cs` and put your new file in `SqlNotebookScript/ScalarFunctions/`. Read `SqlNotebookScript/ScalarFunctions/SystemFunctions.cs` for examples.
2. Write one or more test .sql files in `src/Tests/scripts/`. Read `src/Tests/scripts/UUID.sql` for an example. Run `scripts/build.sh` to make sure your test passes.
3. Write documentation .html in `doc/`. Read `doc/array-concat-func.html` for an example. Copy that exact structure.

# Table-valued function
This is an SQLite virtual module. It requires the function to always return the same table schema known ahead of time; it can't be dynamic based on the arguments.
1. Implement subclass of `SqlNotebookScript/CustomTableFunction.cs` and put your new file in `SqlNotebookScript/TableFunctions/`. Read `SqlNotebookScript/TableFunctions/ListFilesFunction.cs` for examples.
2. Write one or more test .sql files in `src/Tests/scripts/`. Read `src/Tests/scripts/LIST_FILES.sql` for an example. Run `scripts/build.sh` to make sure your test passes.
3. Write documentation .html in `doc/`. Read `doc/list-files-func.html` for an example. Copy that exact structure.

# Macro
This is a function that transforms a statement's AST before execution. The macro function is called for _every_ statement, whether it's applicable or not. The function must search the AST to see if relevant nodes are present, then mutate it. Every `SqlStmt` AST node has a `RunBefore` and `RunAfter` statement list to which you can append statements per the macro's needs. A common approach is to detect a particular function call, insert a `RunBefore` statement that performs the real action and writes to a temporary variable, and mutate the function call into a symbol reference to the temporary variable. Unlike real table-valued functions, this approach allows the simulation of table-valued functions with dynamic table schemas.
1. Implement subclass of `SqlNotebookScript/CustomMacro.cs` and put your new file in `SqlNotebookScript/Macros/`. Read `SqlNotebookScript/Macros/ReadCsvMacro.cs` for examples.
2. Write one or more test .sql files in `src/Tests/scripts/`. Read `src/Tests/scripts/LIST_FILES.sql` for an example. Run `scripts/build.sh` to make sure your test passes.
3. Write documentation .html in `doc/`. Read `doc/list-files-func.html` for an example. Copy that exact structure.

# Grammar production
We have a recursive-descent parser, AST, and interpreter. We call down into SQLite to evaluate expressions and execute SQL statements. Everything is in `src/SqlNotebookScript/Interpreter/`. This is how WHILE, IF, DECLARE, etc. are implemented.
1. Create an AST node class in `src/SqlNotebookScript/Interpreter/Ast/`. Read other files in that directory for examples.
2. Update `src/SqlNotebookScript/Interpreter/ScriptParser.cs` to parse your new language construct into your AST node.
3. Update `src/SqlNotebookScript/Interpreter/ScriptRunner.cs` to execute your AST node.
4. Write one or more test .sql files in `src/Tests/scripts/`. Read `src/Tests/scripts/THROW.sql` for an example. Run `scripts/build.sh` to make sure your test passes.
5. Write documentation .html in `doc/`. Read `doc/throw-stmt.html` for an example. Copy that exact structure.

