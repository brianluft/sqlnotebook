<!DOCTYPE html>
<html>
<head>
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <title>IMPORT XLS Statement</title>
</head>
<body>
  <h1><code>IMPORT</code> <code>XLS</code> Statement</h1>
  <p>Imports an Excel worksheet (in either <span style="font-family: monospace;">.XLS</span> or <span style=
  "font-family: monospace;">.XLSX</span> format) from disk into a notebook table. This statement is the scripting
  equivalent of the visual import wizard accessed via the Import menu. If the workbook contains multiple worksheets,
  use the&nbsp;<span style="font-style: italic;">which-sheet</span> argument to specify which worksheet to import. If
  needed, use the <a href="list-xls-worksheets-func.html"><span style=
  "font-family: monospace;">LIST_XLS_WORKSHEETS</span></a> function to get a list of the worksheets in the
  workbook.</p>
  <h2>Syntax</h2><img moz-do-not-send="true" src="art/rr-import-xls-statement.svg" alt="" class="railroad" width="902"
  height="305">
  <h2>Arguments</h2>
  <ul class="args">
    <li><b>filename</b> (string)<br>
    The absolute path to the Excel workbook (<code>.XLS</code> or <code>.XLSX</code>) to be imported.</li>
    <li><span style="font-weight: bold;">which-sheet</span> (string or integer, optional)<br>
    If specified, this indicates which worksheet to import. If omitted, the first worksheet is imported. This value can
    be either the name of the worksheet or its 1-based index in the workbook.</li>
    <li><b>table-name</b> (identifier or string)<br>
    The name of the notebook table to import the worksheet into. If the table does not exist, it will be created. If it
    does exist, by default new rows will be appended, but the <code>TRUNCATE_EXISTING_TABLE</code> option can be used
    to overwrite the existing table data.</li>
    <li><b>column-name</b> (identifier or string)<br>
    The name of a column in the source file to import. If this column name is not found in the source file, then the
    import operation fails with an error. If no column list is provided, then all columns are imported.</li>
    <li><b>target-column-name</b> (identifier or string)<br>
    If provided, this maps the source column to a different name in the destination table. If not provided, then the
    target column name is the same as the source column name. If multiple columns are mapped to the same target column
    name in this way, then the import operation fails with an error.</li>
    <li>
      <b>data-type</b> (enum)<br>
      If provided, the column data will be parsed into the specified data type. <i>data-type</i> may be one of the
      following values:
      <ul class="enum">
        <li><code>TEXT</code>: The input is imported without change (default)</li>
        <li><code>INTEGER</code>: A positive or negative integer</li>
        <li><code>REAL</code>: Any numeric value</li>
        <li><code>DATE</code>: Best-effort conversion into the text format: "YYYY-MM-DD"</li>
        <li><code>DATETIME</code>: Best-effort conversion into the text format: "YYYY-MM-DD hh:mm:ss.sss"</li>
        <li><code>DATETIMEOFFSET</code>: Best-effort conversion into the text format: "YYYY-MM-DD hh:mm:ss.sss
        +ZZ:ZZ"</li>
      </ul>
    </li>
  </ul>
  <h2>Options</h2>
  <ul class="opts">
    <li><code style="font-weight: bold;">FIRST_ROW</code> (integer ≥ 1, default: 1)<br>
    The number (starting at 1) of the first row of the data to read. If a row of column names is present (see the
    <code>HEADER_ROW</code> option), <code>FIRST_ROW</code> specifies the row containing the column names, with the
    data to follow on the next row. If no column names are present, then <code>FIRST_ROW</code> specifies the first row
    of data.</li>
    <li><code style="font-weight: bold;">LAST_ROW</code> (integer&nbsp;≥ 0, default: 0)<br>
    Indicates how many rows of data to read. If a value of 0 is specified, then all available rows in the worksheet are
    imported. If a positive integer is specified, then it is the last row number (inclusive) to be imported.</li>
    <li><code style="font-weight: bold;">FIRST_COLUMN</code> (integer ≥ 1 or string, default: 1)<br>
    The leftmost column (inclusive) to import. This may be a column number (starting at 1) or a column string (A, B, C,
    ..., XFC, XFD).</li>
    <li><code style="font-weight: bold;">LAST_COLUMN</code> (integer ≥ 0 or string, default: 0)<br>
    The rightmost column (inclusive) to import.&nbsp;This may be a column number (starting at 1) or a column string (A,
    B, C, ..., XFC, XFD).&nbsp;If 0 is specified, then all available columns in the worksheet (after and including
    <code>FIRST_COLUMN</code>) are imported.</li>
    <li>
      <b><code>HEADER_ROW</code></b> (0 or 1, default: 1)<br>
      Indicates whether the worksheet begins with a column header line. If the sheet contains a column header but not
      on the first line of the file, use the <span style="font-family: monospace;">FIRST_ROW</span> option to indicate
      how many rows to skip before the column header appears.
      <ul class="enum">
        <li>0 = No column header. The generic column names <code>column1</code>, <code>column2</code>, etc. will be
        used.</li>
        <li>1 = A column header row exists.</li>
      </ul>
    </li>
    <li>
      <b><code>TRUNCATE_EXISTING_TABLE</code></b> (0 or 1, default: 0)<br>
      If the target table name exists, this option indicates whether the existing data rows should be deleted.
      <ul class="enum">
        <li>0 = Keep existing rows and append new rows</li>
        <li>1 = Delete existing rows</li>
      </ul>
    </li>
    <li>
      <b><code>TEMPORARY_TABLE</code></b> (0 or 1, default: 0)<br>
      If the target table name does not exist, and therefore a new table will be created, this option indicates whether
      the new table will be a temporary table.
      <ul class="enum">
        <li>0 = Use <code>CREATE TABLE</code></li>
        <li>1 = Use <code>CREATE TEMPORARY TABLE</code></li>
      </ul>
    </li>
    <li>
      <b><code>IF_CONVERSION_FAILS</code></b> (integer 1-3, default: 1)<br>
      If data conversion fails (for instance, if a non-numeric value appears in the file in a column defined in the
      <code>IMPORT CSV</code> statement as <code>INTEGER</code>), this option controls what happens.
      <ul class="enum">
        <li>1 = Import the value as plain text</li>
        <li>2 = Skip the data row</li>
        <li>3 = Abort with an error</li>
      </ul>
    </li>
  </ul>
  <h2>Examples</h2>
  <ol class="examples">
    <li><code>IMPORT XLS 'C:\Workbook.xls' INTO mytable;</code><br>
    Imports the first worksheet in "Workbook.xls" into a notebook table called <code>mytable</code>. Because no options
    are specified, it is assumed that the file has a column header on the first line. Because no column list is
    specified, all columns are imported as text and the original column names are preserved.</li>
    <li><code>IMPORT XLSX 'C:\Workbook.xls' INTO tbl1; IMPORT XLS 'C:\Workbook.xlsx' INTO tbl2;</code><br>
    The keywords <code>XLS</code> and <code>XLSX</code> are interchangeable and need not match the file's actual
    extension.</li>
    <li><code>IMPORT XLS 'C:\Workbook.xls' WORKSHEET 1 INTO tbl1;</code><br>
    Imports the first worksheet in the workbook.</li>
    <li><code>IMPORT XLS 'C:\Workbook.xls' WORKSHEET 'Sheet1' INTO tbl1;</code><br>
    Imports the worksheet named "Sheet1".</li>
    <li><code>IMPORT XLS 'C:\Workbook.xls' INTO mytable (foo, bar);</code><br>
    The source columns (<code>foo, bar</code>) are explicitly specified. If the source file contains other columns
    besides those two, then they are not imported into the destination notebook table. If the source file does not
    contain the specified columns, then the import fails. If the destination table already exists and does not contain
    the specified column names, then the import fails.</li>
    <li><code>IMPORT XLS 'C:\Workbook.xls' INTO mytable (foo AS aaa, bar AS bbb);</code><br>
    The source columns (<code>foo, bar</code>) and target columns (<code>aaa</code>, <code>bbb</code>) are explicitly
    specified.</li>
    <li><code>IMPORT XLS 'C:\Workbook.xls' INTO mytable (foo TEXT, bar INTEGER);</code><br>
    A data type conversion is specified for each source column. If the conversion fails (for instance, if a non-numeric
    value appears in the CSV file in the <code>bar</code> column), by default the value is imported as text. SQLite
    treats column types as suggestions, so the integer column can contain a text value.</li>
    <li><code>IMPORT XLS 'C:\Workbook.xls' INTO mytable (column1 AS foo, column2 AS bar) OPTIONS (HEADER_ROW:
    0);</code><br>
    A file that lacks a header row is imported with new names given to the unnamed source columns.</li>
    <li><code>IMPORT XLS @filename INTO @tablename (@old_col AS @new_col);</code><br>
    Various arguments to <code>IMPORT XLS</code> are provided in variables rather than using literal strings. This
    allows these names to be dynamically generated or otherwise determined at script runtime.</li>
  </ol><br>
</body>
</html>
